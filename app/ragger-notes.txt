
Now have option of returning the rag-lambda as a 'created' file
so it appears in the browser. Call it cyber-dojo-traffic-light.rb

In the browser, any file that begins cyber-dojo can be "reserved".
Reserved files appear in lower section and cannot be deleted or renamed,
but can be viewed and edited.

Could add red_amber_green.rb to the starting files for a _new_ kata.
What about forking?

Now puller becomes a properly separate service.
It has a dependency on CSP and LSP which is fine.
It does a docker pull every 24 hours. Job done!
An updated image will be ready for any runner.run_cyber_dojo_sh call.

Looking for incoming cyber-dojo-traffic-light.rb file.
if there isn't one
  you can eval+call, with the extracted original (as per now)
else if its an exact match
  you can eval+call with the extracted original (as per now)
else
  you have to make a 2nd runner call (see below)
end

--------------------------------------------------------------
rag_name_rand = .... # used in ECHO_TRUNCATED_TEXTFILE_NAMES
...
rag_name_true = 'cyber-dojo-traffic-light.rb'

rag_original = created.delete(rag_name_rand)
rag_incoming = files[rag_name_true]

if rag_incoming.nil?
  created[rag_name_true] = rag_original # Add truncation wrap
  eval_call(rag_original)
else if rag_incoming === rag_original
  eval_call(rag_original)
else
  safe_colour_run(rag_incoming)
end

def safe_colour_run(rag_src, stdout, stderr, status)
  rag_files = {
    "stdout" => stdout,
    "stderr" => stderr,
    "status" => status,
    "cyber-dojo.sh" => 'ruby ./run-traffic-light.rb',
    "traffic-light.rb" => rag_src,
    "run-traffic-light.rb" =>
      <<~RUBY
      rag = eval(IO.read('traffic-light.rb'))
      stdout = IO.read('stdout')
      stderr = IO.read('stderr')
      status = IO.read('status')
      print rag.call(stdout, stderr, status)
      RUBY
  }
  container_name = create_container('cyberdojo/ruby-base', id, 2)
  command = tar_pipe_files_in_and_run_cyber_dojo_sh(container_name)
  rgb_stdout,rgb_stderr,rgb_status,timed_out = run(command, rag_files, max_seconds)
  rgb = rgb_stdout['content'].strip
end
