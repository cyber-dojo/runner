
BIGGER
======
Speedup - deployment stages....
 - cat stdout/stderr to files (and echo those back to stdout/stderr)
 - write sss to tar file and tgz that.
 - pipe the echo_textfilenames script into stdin and extract it then run it?
 - echo fully pathed filenames (unrooted) into tar
 - merge two docker execs into one.

Hidden Filenames
----------------
  - can be used as a marker to indicate when a run
    should extract generated text files. LTFs that do that now and dont
    have a hidden_filenames entry will need to create one that == []
    That's only Java-Approval and Ruby-Approval
    Slimed try out...
          Speed up: 0.45 => 0.35  C#, Alpine
                    0.40 => 0.36  VB, Ubuntu
                    0.42 => 0.37  Python, Debian

  - runner should then also process the generated files and apply
    the hidden_filenames filter before returning @created,@deleted,@changed

API change
----------
  - run_cyber_dojo_sh(id, manifest)
     - id is who is making the call.
     - manifest contains:
       - max_seconds
       - image_name:tag
       - visible_files  (from browser) <----- Directly from start-point manifest?
       - hidden_filenames


readonly containers
-------------------
Make TMP-FS for /home/sandbox
Further, if the docker-run used --read-only it would mean
all LTFs were using /tmp and /sandbox only.
That would even make it possible to recycle containers.
You'd only really need to clear out /tmp and /sandbox.
They should be readonly anyway...
What happens to tests with --read-only added...
Only 2 failures
TrafficLightTest
9DB Ubuntu L23
9DD Ubuntu L41
Access to the path /home/sandbox/.mono is denied.
Need to make another tmp-fs for /home/sandbox
TMP_FS_HOME_DIR = "--tmpfs /home/sandbox:exec,size=50M,uid=#{UID},gid=#{GID}"
--read-only
And all pass :-)
Need to try on all LTFs

Image_name:TAG
--------------
  - will now acts as key for cache holding the rag-lambdas.

RAG Lambdas in Python
--------------------
  - visible_files can contain red_amber_green.rb !!!!!
    If present, and different to cached source, then could use it inside
    a runner call that uses Ruby image. This opens up the option of
    allowing lambdas in other languages. Eg Python. Based on the extension.
    And use a known python image.


SMALLER
=======
logger.warning()
logger.info()
logger.error()

TrafficLightTest Hd7 return json in outermost JSON - can be stubbed

log_empty test dFA - can also use stubbing

drop jq and xargs installs in image_dockerfile_augmenter

create a custom BashStub which has methods for the specific bash calls...
      1) docker run --entrypoint=""
      2) docker exec to run cyber-dojo.sh
      3) docker exec to extract text files
      4) docker run --entrypoint=cat to get rag-lambda

uncomment multi_os_test '62B'  Robustness

uncomment c_assert_test 'AB6   RackDispatcher

Dispatcher test that mimics config.ru setup
  Use BashStub.
  Make 2 calls
  Verify stub only gets asked to cat ragfile from image once


---------------------------------------------------------------------

  class CustomBashStub
    def initialize
      @stubs = {}
    end
    def stub_docker_run(stdout, stderr, status)
      @stubs[:cyber_dojo_sh] = { stdout:stdout, stderr:stderr, status:status }
    end
    def stub_cyber_dojo_sh(stdout, stderr, status) # NO THIS IS Process.spawn()
      @stubs[:cyber_dojo_sh] = { stdout:stdout, stderr:stderr, status:status }
    end
    def stub_read_textfiles(tgz)
      @stubs[:tgz] = tgz
    end
    def stub_docker_cat(rag_lambda)
      @stubs[:rag_lambda] = rag_lambda
    end
    def assert(command)
      if command.include?('sleep')
        [@stdout,@stderr,@status]
      end
    end
    def exec(command)
    end
  end
